import pygame
import os
import time

# Инициализация Pygame
pygame.init()
pygame.mixer.init()

# Получаем информацию о экране
info = pygame.display.Info()
screen_width, screen_height = 800, 600
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption("Музыкальный Плеер")

# Цвета
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
LIGHT_GRAY = (240, 240, 240)
MEDIUM_GRAY = (200, 200, 200)
DARK_GRAY = (100, 100, 100)
BLUE = (65, 105, 225)
LIGHT_BLUE = (100, 149, 237)
RED = (220, 60, 60)
GREEN = (60, 179, 113)
HIGHLIGHT = (230, 240, 255)
ACTIVE_BLUE = (30, 144, 255)
BACKGROUND = (248, 248, 255)

# Размеры элементов (увеличил кнопки в 2 раза)
HEADER_HEIGHT = 100
BROWSER_HEIGHT = 320
CONTROLS_HEIGHT = 180
MARGIN = 20
BUTTON_WIDTH = 160  # Увеличен в 2 раза
BUTTON_HEIGHT = 80  # Увеличен в 2 раза
PROGRESS_HEIGHT = 25
VOLUME_WIDTH = 120
VOLUME_HEIGHT = 20

# Шрифты
title_font = pygame.font.Font(None, 42)
header_font = pygame.font.Font(None, 36)
button_font = pygame.font.Font(None, 34)
main_font = pygame.font.Font(None, 30)
small_font = pygame.font.Font(None, 26)

class Button:
    def __init__(self, x, y, width, height, text, color, description=""):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.description = description
        self.color = color
        self.normal_color = color
        self.active_color = (min(color[0] + 30, 255), min(color[1] + 30, 255), min(color[2] + 30, 255))
        self.current_color = color
        self.is_active = False
        self.click_time = 0
        
    def draw(self, surface):
        # Рисуем кнопку с активным состоянием
        if self.is_active:
            pygame.draw.rect(surface, self.active_color, self.rect, border_radius=15)
            pygame.draw.rect(surface, ACTIVE_BLUE, self.rect, 3, border_radius=15)
        else:
            pygame.draw.rect(surface, self.current_color, self.rect, border_radius=15)
            pygame.draw.rect(surface, DARK_GRAY, self.rect, 2, border_radius=15)
        
        # Основной текст
        text_color = BLACK if not self.is_active else ACTIVE_BLUE
        text_surf = button_font.render(self.text, True, text_color)
        text_rect = text_surf.get_rect(center=(self.rect.centerx, self.rect.centery - 12))
        surface.blit(text_surf, text_rect)
        
        # Описание
        if self.description:
            desc_surf = small_font.render(self.description, True, DARK_GRAY)
            desc_rect = desc_surf.get_rect(center=(self.rect.centerx, self.rect.centery + 15))
            surface.blit(desc_surf, desc_rect)
        
    def handle_event(self, event, mouse_pos):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.rect.collidepoint(mouse_pos):
                self.is_active = True
                self.click_time = pygame.time.get_ticks()
                return "clicked"
        
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            if self.rect.collidepoint(mouse_pos) and self.is_active:
                self.is_active = False
                if pygame.time.get_ticks() - self.click_time < 300:
                    return "activated"
        
        if event.type == pygame.MOUSEMOTION:
            if not self.rect.collidepoint(mouse_pos) and self.is_active:
                self.is_active = False
        
        return None

class ProgressBar:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)
        self.progress = 0
        self.dragging = False
        
    def draw(self, surface):
        # Фон
        pygame.draw.rect(surface, LIGHT_GRAY, self.rect, border_radius=6)
        
        # Прогресс
        progress_width = max(10, int(self.rect.width * self.progress))
        progress_rect = pygame.Rect(self.rect.x, self.rect.y, progress_width, self.rect.height)
        pygame.draw.rect(surface, BLUE, progress_rect, border_radius=6)
        
        # Обводка
        pygame.draw.rect(surface, DARK_GRAY, self.rect, 2, border_radius=6)
        
        # Ползунок
        if progress_width > 0:
            slider_x = self.rect.x + progress_width
            slider_rect = pygame.Rect(slider_x - 8, self.rect.y - 6, 16, self.rect.height + 12)
            pygame.draw.rect(surface, WHITE, slider_rect, border_radius=8)
            pygame.draw.rect(surface, ACTIVE_BLUE, slider_rect, 2, border_radius=8)
        
    def handle_event(self, event, mouse_pos):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            slider_x = self.rect.x + int(self.rect.width * self.progress)
            slider_rect = pygame.Rect(slider_x - 15, self.rect.y - 10, 30, self.rect.height + 20)
            
            if slider_rect.collidepoint(mouse_pos) or self.rect.collidepoint(mouse_pos):
                self.dragging = True
                self.update_progress(mouse_pos)
                return True
                
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.dragging = False
            
        elif event.type == pygame.MOUSEMOTION and self.dragging:
            self.update_progress(mouse_pos)
            return True
            
        return False
        
    def update_progress(self, pos):
        relative_x = max(0, min(pos[0] - self.rect.x, self.rect.width))
        self.progress = relative_x / self.rect.width

class VolumeSlider:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)
        self.volume = 0.7
        self.dragging = False
        
    def draw(self, surface):
        # Фон
        pygame.draw.rect(surface, LIGHT_GRAY, self.rect, border_radius=4)
        
        # Уровень громкости
        volume_width = max(5, int(self.rect.width * self.volume))
        volume_rect = pygame.Rect(self.rect.x, self.rect.y, volume_width, self.rect.height)
        pygame.draw.rect(surface, GREEN, volume_rect, border_radius=4)
        
        # Обводка
        pygame.draw.rect(surface, DARK_GRAY, self.rect, 2, border_radius=4)
        
        # Ползунок
        slider_x = self.rect.x + volume_width
        slider_rect = pygame.Rect(slider_x - 6, self.rect.y - 4, 12, self.rect.height + 8)
        pygame.draw.rect(surface, WHITE, slider_rect, border_radius=6)
        pygame.draw.rect(surface, DARK_GRAY, slider_rect, 1, border_radius=6)
        
    def handle_event(self, event, mouse_pos):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            slider_x = self.rect.x + int(self.rect.width * self.volume)
            slider_rect = pygame.Rect(slider_x - 10, self.rect.y - 8, 20, self.rect.height + 16)
            
            if slider_rect.collidepoint(mouse_pos) or self.rect.collidepoint(mouse_pos):
                self.dragging = True
                self.update_volume(mouse_pos)
                return True
                
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.dragging = False
            
        elif event.type == pygame.MOUSEMOTION and self.dragging:
            self.update_volume(mouse_pos)
            return True
            
        return False
        
    def update_volume(self, pos):
        relative_x = max(0, min(pos[0] - self.rect.x, self.rect.width))
        self.volume = relative_x / self.rect.width
        if pygame.mixer.music.get_busy():
            pygame.mixer.music.set_volume(self.volume)

class FileBrowser:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)
        self.current_path = "/storage/emulated/0"
        self.items = []
        self.selected_index = 0
        self.scroll_offset = 0
        self.visible_items = 5  # Меньше элементов для большего размера
        self.scroll_dragging = False
        self.item_dragging = False
        self.scroll_start_y = 0
        self.scroll_start_offset = 0
        self.drag_start_y = 0
        self.last_click_time = 0
        self.confirm_mode = False  # Режим подтверждения выбора
        self.update_file_list()
        
    def update_file_list(self):
        self.items = []
        
        # Кнопка "Назад"
        if self.current_path != "/storage/emulated/0":
            self.items.append(("..", "folder", "Назад"))
        
        try:
            for item in os.listdir(self.current_path):
                full_path = os.path.join(self.current_path, item)
                if os.path.isdir(full_path):
                    self.items.append((item, "folder", "Папка"))
                elif item.lower().endswith(('.mp3', '.wav', '.ogg', '.m4a', '.flac')):
                    self.items.append((item, "music", "Аудио"))
        except (PermissionError, FileNotFoundError):
            print(f"Ошибка доступа: {self.current_path}")
        
    def draw(self, surface):
        # Основной фон
        pygame.draw.rect(surface, WHITE, self.rect, border_radius=10)
        pygame.draw.rect(surface, DARK_GRAY, self.rect, 2, border_radius=10)
        
        # Заголовок
        title_rect = pygame.Rect(self.rect.x - 1, self.rect.y - 50, self.rect.width + 2, 50)
        if self.confirm_mode:
            pygame.draw.rect(surface, GREEN, title_rect, border_radius=10)
        else:
            pygame.draw.rect(surface, BLUE, title_rect, border_radius=10)
        pygame.draw.rect(surface, DARK_GRAY, title_rect, 2, border_radius=10)
        
        # Текст заголовка
        if self.confirm_mode:
            selected_item = self.items[self.selected_index][0] if self.items else ""
            if len(selected_item) > 25:
                selected_item = selected_item[:22] + "..."
            title_text = main_font.render(f"✅ Выбрать: {selected_item}?", True, WHITE)
        else:
            path_display = self.current_path
            if len(path_display) > 40:
                path_display = "..." + path_display[-37:]
            title_text = main_font.render(f"📁 {path_display}", True, WHITE)
        
        surface.blit(title_text, (title_rect.centerx - title_text.get_width()//2, title_rect.y + 15))
        
        if not self.confirm_mode:
            # Элементы списка
            start_index = self.scroll_offset
            end_index = min(start_index + self.visible_items, len(self.items))
            
            for i in range(start_index, end_index):
                item_index = i
                item_name, item_type, item_desc = self.items[item_index]
                
                item_y = self.rect.y + (i - start_index) * 65  # Увеличил высоту элементов
                item_rect = pygame.Rect(self.rect.x + 4, item_y, self.rect.width - 8, 60)
                
                # Выделение
                if item_index == self.selected_index:
                    pygame.draw.rect(surface, HIGHLIGHT, item_rect, border_radius=8)
                    pygame.draw.rect(surface, ACTIVE_BLUE, item_rect, 2, border_radius=8)
                else:
                    pygame.draw.rect(surface, LIGHT_GRAY, item_rect, border_radius=8)
                    pygame.draw.rect(surface, MEDIUM_GRAY, item_rect, 1, border_radius=8)
                
                # Иконка и текст
                icon = "📁" if item_type == "folder" else "🎵" if item_type == "music" else "📄"
                color = BLUE if item_type == "folder" else GREEN if item_type == "music" else DARK_GRAY
                
                display_name = item_name
                if len(display_name) > 28:
                    display_name = display_name[:25] + "..."
                
                icon_text = main_font.render(icon, True, color)
                name_text = main_font.render(display_name, True, BLACK)
                desc_text = small_font.render(item_desc, True, DARK_GRAY)
                
                surface.blit(icon_text, (self.rect.x + 12, item_y + 12))
                surface.blit(name_text, (self.rect.x + 50, item_y + 10))
                surface.blit(desc_text, (self.rect.x + 50, item_y + 35))
            
            # Полоса прокрутки
            if len(self.items) > self.visible_items:
                scrollbar_width = 20
                scrollbar_x = self.rect.x + self.rect.width - scrollbar_width - 4
                
                scroll_bg = pygame.Rect(scrollbar_x, self.rect.y, scrollbar_width, self.rect.height)
                pygame.draw.rect(surface, LIGHT_GRAY, scroll_bg, border_radius=8)
                pygame.draw.rect(surface, MEDIUM_GRAY, scroll_bg, 1, border_radius=8)
                
                scrollbar_height = max(40, self.rect.height * self.visible_items / len(self.items))
                scrollbar_y = self.rect.y + (self.scroll_offset / len(self.items)) * self.rect.height
                scroll_rect = pygame.Rect(scrollbar_x, scrollbar_y, scrollbar_width, scrollbar_height)
                pygame.draw.rect(surface, BLUE, scroll_rect, border_radius=6)
                pygame.draw.rect(surface, ACTIVE_BLUE, scroll_rect, 1, border_radius=6)
        
        else:
            # Режим подтверждения
            confirm_rect = pygame.Rect(self.rect.x + 50, self.rect.y + 80, self.rect.width - 100, 120)
            pygame.draw.rect(surface, LIGHT_GRAY, confirm_rect, border_radius=10)
            pygame.draw.rect(surface, DARK_GRAY, confirm_rect, 2, border_radius=10)
            
            confirm_text = main_font.render("Подтвердите выбор", True, BLACK)
            surface.blit(confirm_text, (confirm_rect.centerx - confirm_text.get_width()//2, confirm_rect.y + 20))
            
            # Кнопки подтверждения
            yes_rect = pygame.Rect(confirm_rect.centerx - 110, confirm_rect.y + 60, 100, 40)
            no_rect = pygame.Rect(confirm_rect.centerx + 10, confirm_rect.y + 60, 100, 40)
            
            pygame.draw.rect(surface, GREEN, yes_rect, border_radius=8)
            pygame.draw.rect(surface, DARK_GRAY, yes_rect, 2, border_radius=8)
            pygame.draw.rect(surface, RED, no_rect, border_radius=8)
            pygame.draw.rect(surface, DARK_GRAY, no_rect, 2, border_radius=8)
            
            yes_text = main_font.render("ДА", True, WHITE)
            no_text = main_font.render("НЕТ", True, WHITE)
            
            surface.blit(yes_text, (yes_rect.centerx - yes_text.get_width()//2, yes_rect.centery - yes_text.get_height()//2))
            surface.blit(no_text, (no_rect.centerx - no_text.get_width()//2, no_rect.centery - no_text.get_height()//2))
        
        # Информация
        if not self.confirm_mode:
            info_text = small_font.render(f"Элементов: {len(self.items)}", True, DARK_GRAY)
            surface.blit(info_text, (self.rect.centerx - info_text.get_width()//2, self.rect.y + self.rect.height + 8))
    
    def handle_event(self, event, mouse_pos):
        current_time = pygame.time.get_ticks()
        
        if self.confirm_mode:
            # Обработка режима подтверждения
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                confirm_rect = pygame.Rect(self.rect.x + 50, self.rect.y + 80, self.rect.width - 100, 120)
                yes_rect = pygame.Rect(confirm_rect.centerx - 110, confirm_rect.y + 60, 100, 40)
                no_rect = pygame.Rect(confirm_rect.centerx + 10, confirm_rect.y + 60, 100, 40)
                
                if yes_rect.collidepoint(mouse_pos):
                    return self.select_item()
                elif no_rect.collidepoint(mouse_pos):
                    self.confirm_mode = False
                    return False
            
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    return self.select_item()
                elif event.key == pygame.K_ESCAPE:
                    self.confirm_mode = False
                    return False
            
            return False
        
        # Обычный режим браузера
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 4:  # Колесо вверх
                self.scroll_offset = max(0, self.scroll_offset - 1)
                return False
            elif event.button == 5:  # Колесо вниз
                self.scroll_offset = min(len(self.items) - self.visible_items, self.scroll_offset + 1)
                return False
        
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if self.rect.collidepoint(mouse_pos):
                scrollbar_width = 20
                scrollbar_x = self.rect.x + self.rect.width - scrollbar_width - 4
                scroll_rect = pygame.Rect(scrollbar_x, self.rect.y, scrollbar_width, self.rect.height)
                
                if scroll_rect.collidepoint(mouse_pos):
                    self.scroll_dragging = True
                    self.scroll_start_y = mouse_pos[1]
                    self.scroll_start_offset = self.scroll_offset
                else:
                    rel_y = mouse_pos[1] - self.rect.y
                    item_index = self.scroll_offset + int(rel_y // 65)
                    
                    if 0 <= item_index < len(self.items):
                        self.selected_index = item_index
                        self.drag_start_y = mouse_pos[1]
                        self.item_dragging = True
                        
                        # Двойное касание для открытия папки
                        if current_time - self.last_click_time < 500:
                            self.last_click_time = 0
                            item_name, item_type, _ = self.items[item_index]
                            if item_type == "folder":
                                return self.select_item()
                            else:
                                self.confirm_mode = True  # Для файлов - режим подтверждения
                                return False
                        self.last_click_time = current_time
        
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            if self.item_dragging and not self.scroll_dragging:
                drag_distance = abs(mouse_pos[1] - self.drag_start_y)
                if drag_distance < 5:  # Простое касание - выделение
                    pass
            
            self.scroll_dragging = False
            self.item_dragging = False
            
        elif event.type == pygame.MOUSEMOTION:
            if self.scroll_dragging:
                scroll_ratio = (mouse_pos[1] - self.rect.y) / self.rect.height
                new_offset = int(scroll_ratio * len(self.items))
                self.scroll_offset = max(0, min(new_offset, len(self.items) - self.visible_items))
                
            elif self.item_dragging and not self.scroll_dragging:
                drag_distance = mouse_pos[1] - self.drag_start_y
                if abs(drag_distance) > 15:
                    items_to_scroll = int(drag_distance / 40)
                    new_offset = self.scroll_offset - items_to_scroll
                    self.scroll_offset = max(0, min(new_offset, len(self.items) - self.visible_items))
                    self.drag_start_y = mouse_pos[1]
        
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_UP:
                self.selected_index = max(0, self.selected_index - 1)
                if self.selected_index < self.scroll_offset:
                    self.scroll_offset = self.selected_index
            elif event.key == pygame.K_DOWN:
                self.selected_index = min(len(self.items) - 1, self.selected_index + 1)
                if self.selected_index >= self.scroll_offset + self.visible_items:
                    self.scroll_offset = self.selected_index - self.visible_items + 1
            elif event.key == pygame.K_RETURN:
                item_name, item_type, _ = self.items[self.selected_index]
                if item_type == "folder":
                    return self.select_item()
                else:
                    self.confirm_mode = True
            elif event.key == pygame.K_ESCAPE:
                if self.current_path != "/storage/emulated/0":
                    self.current_path = os.path.dirname(self.current_path)
                    self.update_file_list()
                    self.selected_index = 0
                    self.scroll_offset = 0
        
        return False
    
    def select_item(self):
        if not self.items:
            return False
            
        item_name, item_type, _ = self.items[self.selected_index]
        
        if item_name == "..":
            self.current_path = os.path.dirname(self.current_path)
            self.update_file_list()
            self.selected_index = 0
            self.scroll_offset = 0
            self.confirm_mode = False
            return False
            
        elif item_type == "folder":
            self.current_path = os.path.join(self.current_path, item_name)
            self.update_file_list()
            self.selected_index = 0
            self.scroll_offset = 0
            self.confirm_mode = False
            return False
            
        elif item_type == "music":
            music_file = os.path.join(self.current_path, item_name)
            self.confirm_mode = False
            return music_file
        
        return False

def main():
    # Создаем элементы интерфейса с новым расположением
    header_rect = pygame.Rect(MARGIN, MARGIN, screen_width - 2*MARGIN, HEADER_HEIGHT)
    browser_rect = pygame.Rect(MARGIN, header_rect.bottom + MARGIN, screen_width - 2*MARGIN, BROWSER_HEIGHT)
    controls_rect = pygame.Rect(MARGIN, browser_rect.bottom + MARGIN, screen_width - 2*MARGIN, CONTROLS_HEIGHT)
    
    # Прогресс бар - опущен на 100 пикселей ниже
    progress_bar = ProgressBar(
        controls_rect.x + 20,
        controls_rect.y + 240,  # Опущен на 100 пикселей ниже (было 140, стало 240)
        controls_rect.width - 40,
        PROGRESS_HEIGHT
    )
    
    # Громкость - сдвинута в бок
    volume_slider = VolumeSlider(
        controls_rect.x + 20,  # Сдвинут влево
        controls_rect.y + 20,
        VOLUME_WIDTH,
        VOLUME_HEIGHT
    )
    
    # Браузер файлов
    file_browser = FileBrowser(
        browser_rect.x,
        browser_rect.y,
        browser_rect.width,
        browser_rect.height
    )
    
    # Кнопки управления (увеличенные в 2 раза)
    button_spacing = 20
    total_buttons_width = BUTTON_WIDTH * 2 + button_spacing
    buttons_start_x = controls_rect.centerx - total_buttons_width // 2
    
    play_button = Button(
        buttons_start_x, controls_rect.y + 15,
        BUTTON_WIDTH, BUTTON_HEIGHT,
        "▶", GREEN, "Воспроизвести"
    )
    
    pause_button = Button(
        buttons_start_x + BUTTON_WIDTH + button_spacing, controls_rect.y + 15,
        BUTTON_WIDTH, BUTTON_HEIGHT,
        "⏸", LIGHT_BLUE, "Пауза"
    )
    
    stop_button = Button(
        buttons_start_x, controls_rect.y + 15 + BUTTON_HEIGHT + 15,
        BUTTON_WIDTH, BUTTON_HEIGHT,
        "⏹", RED, "Стоп"
    )
    
    select_button = Button(
        buttons_start_x + BUTTON_WIDTH + button_spacing, controls_rect.y + 15 + BUTTON_HEIGHT + 15,
        BUTTON_WIDTH, BUTTON_HEIGHT,
        "📁", BLUE, "Выбрать трек"
    )
    
    # Состояние приложения
    music_file = None
    music_loaded = False
    paused = False
    show_file_browser = False
    current_track_name = "Трек не выбран"
    
    running = True
    clock = pygame.time.Clock()
    
    print("🎵 Музыкальный Плеер запущен!")
    
    while running:
        mouse_pos = pygame.mouse.get_pos()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            
            if show_file_browser:
                result = file_browser.handle_event(event, mouse_pos)
                if result:
                    music_file = result
                    music_loaded = True
                    show_file_browser = False
                    current_track_name = os.path.basename(music_file)
                    
                    try:
                        pygame.mixer.music.load(music_file)
                        pygame.mixer.music.set_volume(volume_slider.volume)
                        pygame.mixer.music.play()
                        paused = False
                        progress_bar.progress = 0
                        print(f"🎶 Воспроизведение: {current_track_name}")
                    except Exception as e:
                        print(f"❌ Ошибка: {e}")
                        music_loaded = False
            else:
                # Обработка кнопок
                button_result = select_button.handle_event(event, mouse_pos)
                if button_result == "activated":
                    show_file_browser = True
                
                if music_loaded:
                    if play_button.handle_event(event, mouse_pos) == "activated":
                        pygame.mixer.music.play()
                        paused = False
                    
                    elif pause_button.handle_event(event, mouse_pos) == "activated":
                        if paused:
                            pygame.mixer.music.unpause()
                            paused = False
                        else:
                            pygame.mixer.music.pause()
                            paused = True
                    
                    elif stop_button.handle_event(event, mouse_pos) == "activated":
                        pygame.mixer.music.stop()
                        paused = False
                        progress_bar.progress = 0
                
                # Обработка ползунков
                progress_bar.handle_event(event, mouse_pos)
                volume_slider.handle_event(event, mouse_pos)
                
                # Горячие клавиши
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        if show_file_browser:
                            show_file_browser = False
                        else:
                            running = False
                    elif event.key == pygame.K_SPACE and music_loaded:
                        if paused:
                            pygame.mixer.music.unpause()
                            paused = False
                        else:
                            pygame.mixer.music.pause()
                            paused = True
                    elif event.key == pygame.K_f:
                        show_file_browser = True
        
        # Обновление прогресса воспроизведения
        if music_loaded and pygame.mixer.music.get_busy() and not paused and not progress_bar.dragging:
            if hasattr(pygame.mixer.music, 'get_pos'):
                pos = pygame.mixer.music.get_pos() / 1000.0
                progress_bar.progress = min(pos / 180.0, 1.0)
        
        # Отрисовка
        screen.fill(BACKGROUND)
        
        # Шапка
        pygame.draw.rect(screen, WHITE, header_rect, border_radius=10)
        pygame.draw.rect(screen, DARK_GRAY, header_rect, 2, border_radius=10)
        
        title_text = title_font.render("Музыкальный Плеер", True, BLUE)
        screen.blit(title_text, (header_rect.centerx - title_text.get_width()//2, header_rect.y + 15))
        
        track_text = header_font.render(f"🎵 {current_track_name}", True, DARK_GRAY)
        screen.blit(track_text, (header_rect.centerx - track_text.get_width()//2, header_rect.y + 55))
        
        if show_file_browser:
            # Режим выбора файлов
            file_browser.draw(screen)
            
            # Инструкции
            if file_browser.confirm_mode:
                instructions = ["✅ Подтвердите выбор трека"]
            else:
                instructions = [
                    "🔹 Касание - выделить | Двойное касание - открыть",
                    "🔹 Перетащите для прокрутки | ESC - назад"
                ]
            for i, line in enumerate(instructions):
                text = small_font.render(line, True, DARK_GRAY)
                screen.blit(text, (screen_width//2 - text.get_width()//2, browser_rect.bottom + 15 + i*22))
        else:
            # Основной режим
            # Статус
            if music_loaded:
                status = "⏸ Пауза" if paused else "▶ Играет" if pygame.mixer.music.get_busy() else "⏹ Остановлено"
            else:
                status = "🔇 Трек не выбран"
            
            status_text = main_font.render(status, True, DARK_GRAY)
            screen.blit(status_text, (controls_rect.centerx - status_text.get_width()//2, controls_rect.y - 25))
            
            # Кнопки управления (большие)
            play_button.draw(screen)
            pause_button.draw(screen)
            stop_button.draw(screen)
            select_button.draw(screen)
            
            # Громкость (слева)
            volume_text = small_font.render("Громкость:", True, DARK_GRAY)
            screen.blit(volume_text, (volume_slider.rect.x, volume_slider.rect.y - 20))
            
            volume_slider.draw(screen)
            
            volume_percent = small_font.render(f"{int(volume_slider.volume * 100)}%", True, DARK_GRAY)
            screen.blit(volume_percent, (volume_slider.rect.right + 10, volume_slider.rect.centery - 8))
            
            # Прогресс бар (опущен на 100 пикселей ниже)
            progress_bar.draw(screen)
            
            # Время
            if music_loaded:
                current_time = int(progress_bar.progress * 180)
                total_time = 180
                time_text = f"{current_time//60}:{current_time%60:02d} / {total_time//60}:{total_time%60:02d}"
            else:
                time_text = "0:00 / 0:00"
            
            time_display = small_font.render(time_text, True, BLACK)
            screen.blit(time_display, (progress_bar.rect.centerx - time_display.get_width()//2, progress_bar.rect.bottom + 5))
            
            # Подсказки
            hint_text = small_font.render("ESC - выход | ПРОБЕЛ - пауза | F - выбор трека", True, MEDIUM_GRAY)
            screen.blit(hint_text, (screen_width//2 - hint_text.get_width()//2, screen_height - 25))
        
        pygame.display.flip()
        clock.tick(60)
    
    # Завершение
    if music_loaded:
        pygame.mixer.music.stop()
    pygame.quit()

if __name__ == "__main__":
    main()
